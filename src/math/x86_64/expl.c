#ifndef __LONG_DOUBLE_64__

/* exp(x) = 2^hi + 2^hi (2^lo - 1)
 * where hi+lo = log2e*x with 128bit precision
 * exact log2e*x calculation depends on nearest rounding mode
 * using the exact multiplication method of Dekker and Veltkamp
 */

__asm__ (
	".global expl\n"
	".type expl,@function\n"
	"expl:\n"
	"	fldt 8(%rsp)\n"
	"\n"
	"		# interesting case: 0x1p-32 <= |x| < 16384\n"
	"		# check if (exponent|0x8000) is in [0xbfff-32, 0xbfff+13]\n"
	"	mov 16(%rsp), %ax\n"
	"	or $0x8000, %ax\n"
	"	sub $0xbfdf, %ax\n"
	"	cmp $45, %ax\n"
	"	jbe 2f\n"
	"	test %ax, %ax\n"
	"	fld1\n"
	"	js 1f\n"
	"		# if |x|>=0x1p14 or nan return 2^trunc(x)\n"
	"	fscale\n"
	"	fstp %st(1)\n"
	"	ret\n"
	"		# if |x|<0x1p-32 return 1+x\n"
	"1:	faddp\n"
	"	ret\n"
	"\n"
	"		# should be 0x1.71547652b82fe178p0L == 0x3fff b8aa3b29 5c17f0bc\n"
	"		# it will be wrong on non-nearest rounding mode\n"
	"2:	fldl2e\n"
	"	subq $48, %rsp\n"
	"		# hi = log2e_hi*x\n"
	"		# 2^hi = exp2l(hi)\n"
	"	fmul %st(1),%st\n"
	"	fld %st(0)\n"
	"	fstpt (%rsp)\n"
	"	fstpt 16(%rsp)\n"
	"	fstpt 32(%rsp)\n"
	"	call exp2l@PLT\n"
	"		# if 2^hi == inf return 2^hi\n"
	"	fld %st(0)\n"
	"	fstpt (%rsp)\n"
	"	cmpw $0x7fff, 8(%rsp)\n"
	"	je 1f\n"
	"	fldt 32(%rsp)\n"
	"	fldt 16(%rsp)\n"
	"		# fpu stack: 2^hi x hi\n"
	"		# exact mult: x*log2e\n"
	"	fld %st(1)\n"
	"		# c = 0x1p32+1\n"
	"	movq $0x41f0000000100000,%rax\n"
	"	pushq %rax\n"
	"	fldl (%rsp)\n"
	"		# xh = x - c*x + c*x\n"
	"		# xl = x - xh\n"
	"	fmulp\n"
	"	fld %st(2)\n"
	"	fsub %st(1), %st\n"
	"	faddp\n"
	"	fld %st(2)\n"
	"	fsub %st(1), %st\n"
	"		# yh = log2e_hi - c*log2e_hi + c*log2e_hi\n"
	"	movq $0x3ff7154765200000,%rax\n"
	"	pushq %rax\n"
	"	fldl (%rsp)\n"
	"		# fpu stack: 2^hi x hi xh xl yh\n"
	"		# lo = hi - xh*yh + xl*yh\n"
	"	fld %st(2)\n"
	"	fmul %st(1), %st\n"
	"	fsubp %st, %st(4)\n"
	"	fmul %st(1), %st\n"
	"	faddp %st, %st(3)\n"
	"		# yl = log2e_hi - yh\n"
	"	movq $0x3de705fc2f000000,%rax\n"
	"	pushq %rax\n"
	"	fldl (%rsp)\n"
	"		# fpu stack: 2^hi x lo xh xl yl\n"
	"		# lo += xh*yl + xl*yl\n"
	"	fmul %st, %st(2)\n"
	"	fmulp %st, %st(1)\n"
	"	fxch %st(2)\n"
	"	faddp\n"
	"	faddp\n"
	"		# log2e_lo\n"
	"	movq $0xbfbe,%rax\n"
	"	pushq %rax\n"
	"	movq $0x82f0025f2dc582ee,%rax\n"
	"	pushq %rax\n"
	"	fldt (%rsp)\n"
	"	addq $40,%rsp\n"
	"		# fpu stack: 2^hi x lo log2e_lo\n"
	"		# lo += log2e_lo*x\n"
	"		# return 2^hi + 2^hi (2^lo - 1)\n"
	"	fmulp %st, %st(2)\n"
	"	faddp\n"
	"	f2xm1\n"
	"	fmul %st(1), %st\n"
	"	faddp\n"
	"1:	addq $48, %rsp\n"
	"	ret\n"
);

#else

#include "../expl.c"

#endif
